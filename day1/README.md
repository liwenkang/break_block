# 2018年9月13日 22:07:21

想要完成一个打砖块游戏,在这个过程中,我们将通过对代码合理的封装,让代码看起来不那么挫...

刚开始,不需要先想好怎么做封装,先写一个流水线式的代码也不错

通过 canvas ,我们可以新建一个画布,把打砖块需要的挡板(一张图片)加载进去.

在挡板加载进去之后, 如何让挡板实现左右移动呢?

画布实际上是通过不断地重画,实现动作的,所以,我们需要解决的问题就是首先清空画布,然后再画新的

刚开始,我们尝试了使用监听键盘的事件,使得挡板可以左右移动

在实现左右移动的功能后,发现画面掉帧严重.也就是说我们一直按下向左/向右后, keydown 事件的触发频率很低.
为了解决这一问题,我们使用了 setInterval ,它接受两个参数,第一个是要触发的函数,第二个是触发频率(1000豪秒/30次),这样,我们就可以以固定的频率,调用画布重绘了

这个时候,把一些小的细节调节好之后,(比如向左,向右移动其实是一个状态,通过一个标志位区别),就实现了挡板的左右移动,此时,我们的代码就是最烂的流水线式的代码了,我们这个时候就可以开始对程序进行一些调整了

首先,程序的最外层应该只有函数,没有全局变量,而且应该只有一个主函数,我们写为 __main() ,把所有程序放到主程序里面后,我们开始对挡板这个对象就行封装

我们的挡板实际上一个图片,所以,先把加载图片的代码封装为一个函数 imageFromPath() ,函数的功能就是传入一个图片路径,返回一个加载后的 img

接下来,我们把挡板抽象为一个函数(Paddle),并在其中定义了一个对象,它有自己的属性(比如位置, 速度, 图片),自己的方法(向左移,向右移),在函数末尾返回这个对象.

这个时候,我们发现代码中最丑的部分就是关于事件监听的处理了.
由于挡板的移动,实际上是通过画布的重绘实现的,所以我们先把画布部分抽象出一个函数(GuaGame).
在这里面,我们定义了一个新的对象,保存了画布的行为(actions),它有多个方法(drawImage: 将对象传入后,就在画布中画出这个对象; registerAction: 将注册事件绑定到 actions 属性中, key 是按键名称, callback 是相应要执行的函数),将对键盘监听的结果(也就是按键的状态)存到 keydowns 中,将画布的刷新(setInterval)放在这个函数中, 并在 setInterval 的第一个参数中,对 g.actions 的 key 进行遍历,如果有对应的 keydowns 值为 true ,也就是有键盘事件触发,则执行响应的 callback ,随后刷新画布,包含更新状态,清空画布,以及重绘三步.最后在函数的末尾返回这个对象.

现在我们的代码在实现挡板左右移动的条件下, 比之前好看了很多.

之后,我们把球也加到画布中,很明显球和挡板非常相似,所以,我们直接复制一份挡板的模版.
进行修改,注意球是可以上下左右移动的,所以有X轴和Y轴两个方向上的速度.球有自己的运行状态属性(fired), 方法(move: 处于运动状态; fire: 改变球的运行状态).
注意在发射之后,球才开始运动,并且球不可以超出画布.

最后,我们在主函数中 __main() 分别引入: 画布的抽象 GuaGame(), 挡板的抽象 Paddle(), 球的抽象 Ball().
画布的实时更新,一方面更新的是挡板的移动,另一方面更新的是小球的移动.
然后在画布上注册挡板的左右移动事件,以及球的发射事件.
注意球在画布中处于运动状态的时候,要考虑一下球和挡板的碰撞逻辑,发生碰撞的条件,我们可以先简单的考虑为: Y轴方向上, 球的下边沿碰到挡板的上边沿的同时,X轴方向上,球的左边缘和右边缘都在挡板的范围内.发生碰撞的结果就是小球 Y 轴的速度反向.
最后,将挡板和小球重绘在画布中

至此,我们的程序完成了最基础的功能,可以移动挡板,发射球,且小球在碰到画布四周和挡板的时候会发生反弹

残留的问题: 
1. 挡板运动时应该和小球一样,限制在画布中
2. 判断的条件太过于模糊